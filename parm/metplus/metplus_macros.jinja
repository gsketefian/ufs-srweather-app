{#-
This macro prints out an error message and quits the jinja templater.
#}
{%- macro print_err_and_quit(error_msg) %}
  {%- include 'ERROR: ' ~ error_msg %}
{%- endmacro %}
{#-
Given a specified field level that is really an accumulation period, this
macro prints out an "A" followed by the accumulation period (an integer)
with any leading zeros removed.  For example, if the level is 'A03', it
prints out 'A3'.
#}
{%- macro get_accumulation_no_zero_pad(level) %}
  {%- set first_char = level[0] %}
  {%- set the_rest = level[1:] %}
  {%- if (first_char == 'A') %}
    {{- first_char ~ '%d'%the_rest|int }}
  {%- else %}
    {{- level }}
  {%- endif %}
{%- endmacro %}
{#-
This macro checks whether the specified level (input_level) has a valid
value.  input_level may be set to 'all' or to a specific level.  If set
to 'all', input_level is not checked because in this case, whatever valid/
available levels are found will be included in the METplus configuration
file for all specified fields.  input_level IS checked if it is set to
any other value because in this case, all the specified fields will use
only that specific level in the METplus configuration file, which implies
that the level must be valid for all such fields.
#}
{%- macro check_level(fields_levels_threshes, input_level) %}

  {%- if input_level != 'all' %}

    {%- set num_valid_fields = fields_levels_threshes|length %}
    {%- set valid_fields = [] %}
    {%- for i in range(0,num_valid_fields) %}
      {%- set field = fields_levels_threshes[i].keys()|list|join('') %}
      {%- set tmp = valid_fields.append(field) %}
    {%- endfor %}

    {%- for i in range(0,num_valid_fields) %}
      {%- set field = valid_fields[i] %}
      {%- set valid_levels = fields_levels_threshes[i][field].keys()|list %}
      {%- if input_level not in valid_levels %}
        {%- set error_msg = '\n' ~
              'The specified level (input_level) is not in the list of valid levels\n' ~
              '(valid_levels) for the current field (field):\n' ~
              '  field = \'' ~ field ~ '\'\n' ~
              '  valid_levels = ' ~ valid_levels ~ '\n'
              '  input_level = \'' ~ input_level ~ '\'\n'
              'input_level must either be set to the string \'all\' (to include all valid\n' ~
              'values in the verification) or to one of the elements in valid_levels.' %}
        {{print_err_and_quit(error_msg)}}
      {%- endif %}
    {%- endfor %}

  {%- endif %}

{%- endmacro %}
{#-
This macro checks whether the specified threshold (input_thresh) has a
valid value.  input_thresh may be set to 'none', 'all', or a specific
threshold.  If set to 'none', input_thresh is not checked for a valid 
value since threshold information will not be included in the METplus
configuration file.  input_thresh is also not checked for a valid value
if it set to 'all' because in this case, whatever valid/available thresholds
are found will be included in the METplus configuration file for all
specified field and level combination.  Finally, input_thresh IS checked
for a valid value if it is set to something other than 'none' and 'all'
because in this case, all specified field and level combinations (where
the latter, depending on the value of input_level, may be either all
valid/available levels or a single one) will use only that specific 
threshold in the METplus configuration file, which implies that the
threshold must be valid for all such field and level combinations.
#}
{%- macro check_thresh(fields_levels_threshes, input_level, input_thresh) %}

  {%- if (input_thresh != 'none') and (input_thresh != 'all') %}

    {%- set num_valid_fields = fields_levels_threshes|length %}
    {%- set valid_fields = [] %}
    {%- for i in range(0,num_valid_fields) %}
      {%- set field = fields_levels_threshes[i].keys()|list|join('') %}
      {%- set tmp = valid_fields.append(field) %}
    {%- endfor %}

    {%- for i in range(0,num_valid_fields) %}
      {%- set field = valid_fields[i] %}
      {%- set valid_levels = fields_levels_threshes[i][field].keys()|list %}
      {%- set valid_levels_threshes = fields_levels_threshes[i][field] %}

      {%- for level, valid_threshes in valid_levels_threshes.items() %}
        {%- if (input_level == 'all') or (input_level == level) %}
          {%- if input_thresh not in valid_threshes %}
            {%- set error_msg = '\n' ~
'The specified threshold (input_thresh) is not in the list of valid\n' ~
'thresholds (valid_threshes) for the current field (field) and level\n' ~
'(level) combination:\n' ~
'  field = \'' ~ field ~ '\'\n' ~
'  level = \'' ~ level ~ '\'\n' ~
'  valid_threshes = ' ~ valid_threshes ~ '\n'
'  input_thresh = \'' ~ input_thresh ~ '\'' %}
'input_thresh must be set to the string \'all\' (to include in the METplus\n' ~
'configuration file all thresholds for each valid combination of field and\n' ~
'level), to the string \'none\' (to include no threshold information in the\n' ~
'METplus configuration file), or to one of the elements in valid_threshes\n' ~
'(to include only that specific threshold in the METplus configuration file).' %}
            {{print_err_and_quit(error_msg)}}
          {%- endif %}
        {%- endif %}

      {%- endfor %}

    {%- endfor %}

  {%- endif %}

{%- endmacro %}
{#-
This macro extracts from the input dictionary fields_levels_threshes that
contains information on field names, levels, and thresholds for both the
forecasts and observations into two dictionaries, one containing this 
information for the forecasts and another for the observations.  It then
prints out one of these two resultig dictionaries as a "return" value. 
(It would be nice to return both, but that requires more complicated 
code in the calling routine.)
#}
{%- macro separate_fcst_obs_info(fields_levels_threshes, fcst_or_obs) %}
{#-
Make sure that fcst_or_obs has a valid value.
#}
  {%- set valid_fcst_or_obs = ['fcst', 'obs'] %}
  {%- if fcst_or_obs not in valid_fcst_or_obs %}
    {%- set error_msg = '\n' ~
          'The input argument \'fcst_or_obs\' does not have a valid value:\n' ~
          '  fcst_or_obs = \'' ~ fcst_or_obs ~ '\'\n' ~
          'Valid values are:\n' ~
          '  valid_fcst_or_obs = ' ~ valid_fcst_or_obs ~ '\n'
          'Please ensure that a valid value is supplied for \'fcst_or_obs\' and rerun.\n' %}
    {{print_err_and_quit(error_msg)}}
  {%- endif %}
{#-
Set the character that, in the various strings representing a field, level,
or threshold, separates the forecast value from the observation value.
#}
  {%- set sep_char = '|' %}
{#-
Separate the information in the given field name, levels, and thresholds  
dictionary into a fields-and-levels-and-thresholds dictionary for forecasts
and another one for thresholds.
#}
  {%- set fields_levels_threshes_fcst = {} %}
  {%- set fields_levels_threshes_obs = {} %}
  {%- for field_both, levels_threshes_both in fields_levels_threshes.items() %}
{#-
For the current field, get both the forecast and observation field name.
#}
    {%- set tmp = field_both.split('|') %}
    {%- set num_sep_chars = tmp|length() - 1 %}
    {%- set field_fcst = tmp[0]|trim %}
    {%- if num_sep_chars == 0 %}
      {%- set field_obs = field_fcst %}
    {%- elif num_sep_chars == 1 %}
      {%- set field_obs = tmp[1]|trim %}
    {%- else %}
      {%- set error_msg = '\n' ~
            'The field entries in the fields-and-levels-and-thresholds dictionary can contain at\n' ~
            'most one separator character (in this case a \'' ~ sep_char ~ '\'), but the current field contains ' ~ num_sep_chars ~ ':\n' ~
            '  field_both = \'' ~ field_both ~ '\'\n' ~
            'Please fix and rerun.' %}
      {{print_err_and_quit(error_msg)}}
    {%- endif %}
{#-
For the current field, loop over levels and for each one, get both the
forecast and observation level.
#}
    {%- set levels_threshes_fcst = {} %}
    {%- set levels_threshes_obs = {} %}
    {%- for level_both, threshes_both in levels_threshes_both.items() %}
      {%- set tmp = level_both.split('|') %}
      {%- set num_sep_chars = tmp|length() - 1 %}
      {%- set level_fcst = tmp[0]|trim%}
      {%- if num_sep_chars == 0 %}
        {%- set level_obs = level_fcst %}
      {%- elif num_sep_chars == 1 %}
        {%- set level_obs = tmp[1]|trim %}
      {%- else %}
        {%- set error_msg = '\n' ~
              'The level entries in the levels-and-thresholds dictionary can contain at most one\n' ~
              'separator character (in this case a \'' ~ sep_char ~ '\'), but the current level contains ' ~ num_sep_chars ~ ':\n' ~
              '  level_both = \'' ~ level_both ~ '\'\n' ~
              'Please fix and rerun.' %}
        {{print_err_and_quit(error_msg)}}
      {%- endif %}
{#-
For the current level, loop over thresholds and for each one, get both the
forecast and observation threshold.
#}
      {%- set threshes_fcst = [] %}
      {%- set threshes_obs = [] %}
      {%- for thresh_both in threshes_both %}
        {%- set tmp = thresh_both.split('|') %}
        {%- set num_sep_chars = tmp|length() - 1 %}
        {%- set thresh_fcst = tmp[0]|trim%}
        {%- if num_sep_chars == 0 %}
          {%- set thresh_obs = thresh_fcst %}
        {%- elif num_sep_chars == 1 %}
          {%- set thresh_obs = tmp[1]|trim %}
        {%- else %}
          {%- set error_msg = '\n' ~
                'The threshold entries in the thresholds list can contain at most one separator\n' ~
                'character (in this case a \'' ~ sep_char ~ '\'), but the current threshold contains ' ~ num_sep_chars ~ ':\n' ~
                '  thresh_both = \'' ~ thresh_both ~ '\'\n' ~
                'Please fix and rerun.' %}
          {{print_err_and_quit(error_msg)}}
        {%- endif %}
{#-
Append the current forecast threshold to the list of forecast thresholds
corresponding to the current field and level.  Then do the same for the
observations.
#}
        {%- set tmp = threshes_fcst.append(thresh_fcst) %}
        {%- set tmp = threshes_obs.append(thresh_obs) %}
      {%- endfor %}
{#-
Set the key-value pair consisting of the current forecast level (the key)
and corresponding list of forecast thresholds (the value) in the levels-
and-thresholds forecast dictionary of the current field.  Then do the
same for the observations.
#}
      {%- set tmp = levels_threshes_fcst.__setitem__(level_fcst, threshes_fcst) %}
      {%- set tmp = levels_threshes_obs.__setitem__(level_obs, threshes_obs) %}
    {%- endfor %}
{#-
Set the key-value pair consisting of the current forecast field name (the
key) and corresponding forecast levels-and-thresholds forecast dictionary
(the value) in the fields-and-levels-and-thresholds forecast dictionary.
Then do the same for the observations.
#}
    {%- set tmp = fields_levels_threshes_fcst.__setitem__(field_fcst, levels_threshes_fcst) %}
    {%- set tmp = fields_levels_threshes_obs.__setitem__(field_obs, levels_threshes_obs) %}
  {%- endfor %}
{#-
Depending on the setting of fcst_or_obs, print out either the fields-levels-
thresholds dictionary for the forecasts or the one for the observations
#}
  {%- if fcst_or_obs == 'fcst' %}
    {{-fields_levels_threshes_fcst}}
  {%- elif fcst_or_obs == 'obs' %}
    {{-fields_levels_threshes_obs}}
  {%- endif %}
{%- endmacro %}
{#-
This macro checks whether, for the given field, the list of thresholds 
for all levels are identical.  If not, it prints out an error message
and errors out.
#}
{%- macro check_for_identical_threshes_by_level(field, levels_threshes) %}
  {%- set avail_levels = levels_threshes[field].keys()|list %}
  {%- set num_avail_levels = avail_levels|length %}
  {%- set threshes_by_avail_level = levels_threshes[field].values()|list %}
  {%- for i in range(1,num_avail_levels) %}
    {%- set level = avail_levels[i-1] %}
    {%- set threshes = threshes_by_avail_level[i-1] %}
    {%- set level_next = avail_levels[i] %}
    {%- set threshes_next = threshes_by_avail_level[i] %}
    {%- if (threshes_next != threshes) %}
      {%- set error_msg = '\n\n' ~
'For the given field (field), the set of thresholds for the next level\n' ~
'(threshes_next, level_next) is not equal to that of the current level\n' ~
'(threshes, level) (note that order of thresholds matters here):\n' ~
'  field = \'' ~ field ~ '\'\n' ~
'  num_avail_levels = ' ~ num_avail_levels ~ '\n' ~
'  level = \'' ~ level ~ '\'\n' ~
'  threshes = ' ~ threshes ~ '\n' ~
'  level_next = \'' ~ level_next ~ '\'\n' ~
'  threshes_next = ' ~ threshes_next ~ '\n'
      %}
      {{print_err_and_quit(error_msg)}}
    {%- endif %}
  {%- endfor %}
{%- endmacro %}
